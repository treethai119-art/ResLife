# CheckIn v2: Pragmatic Pipeline
## Addressing Real Critiques Without Over-Engineering

---

# TRIAGE: WHAT ACTUALLY MATTERS

| Critique | Fix? | Why |
|----------|------|-----|
| Magic thresholds | YES | Externalize to config, calibrate later |
| App crashes on OCR fail | YES | Error handling is table stakes |
| O'Brien/JosÃ© names broken | YES | Real users excluded |
| "Not Monday" parsed wrong | YES | Wrong schedules = missed check-ins |
| No confidence scores | YES | User doesn't know what to review |
| ILP scheduling | NO | Greedy works fine for 50 residents |
| Full Mayer-Vietoris | NO | Direct h1() IS correct for graphs |
| RFC 5322 email validation | NO | @school.edu is fine |
| Learned connection weights | NO | Heuristics work, calibrate in v3 |

---

# ARCHITECTURE v2

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           CheckIn v2 ARCHITECTURE                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CONFIG LAYER   â”‚     â”‚   ERROR LAYER    â”‚     â”‚  VALIDATION      â”‚
â”‚                  â”‚     â”‚                  â”‚     â”‚  LAYER           â”‚
â”‚ â€¢ All thresholds â”‚     â”‚ â€¢ Result<T,E>    â”‚     â”‚ â€¢ Confidence     â”‚
â”‚ â€¢ Weights        â”‚     â”‚ â€¢ Graceful       â”‚     â”‚   scores         â”‚
â”‚ â€¢ Feature flags  â”‚     â”‚   degradation    â”‚     â”‚ â€¢ Review flags   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                        â”‚                        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
              â”‚  INTAKE   â”‚               â”‚  ANALYSIS â”‚
              â”‚           â”‚               â”‚           â”‚
              â”‚ â€¢ OCR     â”‚               â”‚ â€¢ Homologyâ”‚
              â”‚ â€¢ NLP     â”‚               â”‚ â€¢ Priorityâ”‚
              â”‚ â€¢ CSV     â”‚               â”‚ â€¢ Scheduleâ”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# MODULE 1: CONFIGURATION

**Problem:** Magic numbers scattered in code
**Solution:** Single config file, all values documented

```typescript
// config.ts - THE ONLY PLACE THRESHOLDS LIVE

export const CONFIG = {
  // =========================================================================
  // PARSING
  // =========================================================================
  parsing: {
    // OCR confidence below this triggers manual review
    ocr_confidence_threshold: 0.7,  // CALIBRATE: Start at 0.7, adjust based on error rate
    
    // Minimum fields required to accept a resident record
    min_required_fields: ['name', 'room'],  // Phone/email can be added manually
    
    // Time parsing defaults
    default_available_start: '08:00',  // CONFIGURABLE per institution
    default_available_end: '22:00',    // Some schools have later hours
    
    // Negation keywords for availability parsing
    negation_words: ['not', 'except', 'busy', 'cant', "can't", 'unavailable', 'no'],
  },
  
  // =========================================================================
  // COMMUNITY ANALYSIS
  // =========================================================================
  community: {
    // Connection strength thresholds
    connection_min_strength: 0.5,  // Below this, don't create edge
    connection_strong_threshold: 2.0,  // Above this, "strong" connection
    
    // Boundary detection (isolation risk)
    // Residents in bottom X% of connections are "boundary"
    boundary_percentile: 0.2,  // Bottom 20% = isolation risk
    
    // Health score weights (must sum to 1.0)
    health_weights: {
      connectivity: 0.3,   // Î²â‚€ component
      cohesion: 0.3,       // Î²â‚ component  
      isolation: 0.4,      // Boundary resident count
    },
    
    // Size normalization
    // For n residents, normalize Î²â‚ by: Î²â‚ / (n * this_factor)
    // Rationale: Larger communities naturally have more cycles
    cycle_normalization_factor: 0.1,  // CALIBRATE with real data
  },
  
  // =========================================================================
  // CONNECTION WEIGHTS
  // =========================================================================
  // These are heuristics. Will be replaced with learned weights in v3.
  connection_weights: {
    shared_class: 2.0,        // Each shared class
    schedule_overlap_per_hour: 0.2,  // Per hour of weekly overlap
    shared_interest: 1.5,     // Each shared interest
    roommate: 5.0,            // Same room
    floor_proximity: 1.0,     // Within 5 room numbers
    ra_introduced: 3.0,       // RA made introduction
  },
  
  // =========================================================================
  // SCHEDULING
  // =========================================================================
  scheduling: {
    // Batch optimization
    max_batch_size: 3,        // Max residents per time slot
    room_proximity_bonus: 20,  // Bonus for nearby rooms
    batch_size_bonus: 5,       // Bonus per resident in batch
    
    // Greedy passes (try multiple orderings)
    greedy_passes: 3,  // Run greedy 3x with different orderings
    
    // Priority weights for check-in ordering
    priority_weights: {
      isolation_risk: 30,      // Boundary resident bonus
      fragile_group: 20,       // In fragile community structure
      low_rating: 25,          // Last check-in was 1-2
      follow_up_needed: 15,    // Flagged for follow-up
      bridge_resident: 5,      // Connector (important but not urgent)
      stable_group: -10,       // In stable structure (lower priority)
    },
  },
  
  // =========================================================================
  // FEATURE FLAGS
  // =========================================================================
  features: {
    enable_homology: true,     // Full topology analysis
    enable_persistence: true,  // Track stability over time
    enable_auto_introductions: true,  // Suggest introductions
    enable_event_optimization: true,  // Optimal event timing
  },
};

// Type-safe config access
export type Config = typeof CONFIG;
```

---

# MODULE 2: ERROR HANDLING

**Problem:** App crashes, user abandons
**Solution:** Result type, graceful degradation

```typescript
// result.ts - Rust-style Result type

export type Result<T, E = Error> = 
  | { ok: true; value: T }
  | { ok: false; error: E };

export const Ok = <T>(value: T): Result<T, never> => ({ ok: true, value });
export const Err = <E>(error: E): Result<never, E> => ({ ok: false, error });

export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
  return result.ok ? result.value : defaultValue;
}

export function map<T, U, E>(result: Result<T, E>, fn: (t: T) => U): Result<U, E> {
  return result.ok ? Ok(fn(result.value)) : result;
}

// Error types
export interface ParseError {
  code: 'OCR_FAILED' | 'INVALID_FORMAT' | 'MISSING_FIELD' | 'CONFIDENCE_LOW';
  message: string;
  field?: string;
  suggestion?: string;
}

export interface SchedulingError {
  code: 'NO_AVAILABILITY' | 'CONFLICT' | 'CAPACITY_EXCEEDED';
  residentId: string;
  message: string;
  alternatives?: string[];
}
```

```typescript
// Wrapping OCR with error handling

async function processRosterImage(file: File): Promise<Result<ParsedRoster, ParseError>> {
  try {
    const worker = await Tesseract.createWorker('eng');
    
    // Set timeout - OCR shouldn't take > 30s
    const timeoutPromise = new Promise<never>((_, reject) => 
      setTimeout(() => reject(new Error('OCR timeout')), 30000)
    );
    
    const ocrPromise = worker.recognize(file);
    const { data } = await Promise.race([ocrPromise, timeoutPromise]);
    
    await worker.terminate();
    
    // Check overall confidence
    if (data.confidence < CONFIG.parsing.ocr_confidence_threshold * 100) {
      return Err({
        code: 'CONFIDENCE_LOW',
        message: `OCR confidence ${data.confidence}% is below threshold`,
        suggestion: 'Try a clearer image or upload CSV instead'
      });
    }
    
    const residents = parseRosterText(data.text, data.blocks);
    return Ok({ residents, rawText: data.text, confidence: data.confidence / 100 });
    
  } catch (e) {
    return Err({
      code: 'OCR_FAILED',
      message: e instanceof Error ? e.message : 'Unknown OCR error',
      suggestion: 'Upload a CSV file as fallback'
    });
  }
}
```

```typescript
// Graceful degradation in UI

function RosterUpload() {
  const [result, setResult] = useState<Result<ParsedRoster, ParseError> | null>(null);
  
  const handleUpload = async (file: File) => {
    const result = await processRosterImage(file);
    setResult(result);
  };
  
  if (result && !result.ok) {
    return (
      <div className="error-state">
        <h3>âš ï¸ {result.error.message}</h3>
        {result.error.suggestion && <p>{result.error.suggestion}</p>}
        
        {/* Fallback options */}
        <div className="fallback-options">
          <button onClick={() => setShowCSVUpload(true)}>
            ğŸ“„ Upload CSV Instead
          </button>
          <button onClick={() => setShowManualEntry(true)}>
            âœï¸ Enter Manually
          </button>
          <button onClick={() => setResult(null)}>
            ğŸ”„ Try Different Image
          </button>
        </div>
      </div>
    );
  }
  
  // ... normal flow
}
```

---

# MODULE 3: UNICODE-SAFE PARSING

**Problem:** Names like O'Brien, JosÃ©, MarÃ­a get mangled
**Solution:** Unicode-aware regex, preserve all characters

```typescript
// name_parser.ts

interface ParsedName {
  firstName: string;
  lastName: string;
  confidence: number;
  needsReview: boolean;
}

function parseName(raw: string): ParsedName {
  // Clean but preserve Unicode, apostrophes, hyphens
  const cleaned = raw
    .trim()
    // Remove only clearly non-name characters
    .replace(/[0-9@#$%^&*()+=\[\]{}|\\<>]/g, '')
    // Normalize multiple spaces
    .replace(/\s+/g, ' ')
    .trim();
  
  if (!cleaned) {
    return { firstName: '', lastName: '', confidence: 0, needsReview: true };
  }
  
  // Split on whitespace, preserving all Unicode letters
  const parts = cleaned.split(' ').filter(p => p.length > 0);
  
  if (parts.length === 0) {
    return { firstName: '', lastName: '', confidence: 0, needsReview: true };
  }
  
  if (parts.length === 1) {
    // Single name - flag for review
    return { 
      firstName: parts[0], 
      lastName: '', 
      confidence: 0.5, 
      needsReview: true 
    };
  }
  
  // Check for common patterns
  const lastPart = parts[parts.length - 1];
  
  // Detect suffix (Jr, Sr, III, etc.)
  const suffixPattern = /^(Jr\.?|Sr\.?|II|III|IV|PhD|MD|Esq\.?)$/i;
  const hasSuffix = suffixPattern.test(lastPart);
  
  if (hasSuffix && parts.length >= 3) {
    // "John Smith Jr" -> firstName: John, lastName: Smith Jr
    return {
      firstName: parts[0],
      lastName: parts.slice(1).join(' '),
      confidence: 0.85,
      needsReview: false
    };
  }
  
  // Standard case: First Last or First Middle Last
  // Assume LAST part is surname (works for Western names)
  // Flag multi-part names for review (could be different conventions)
  const confidence = parts.length === 2 ? 0.9 : 0.7;
  
  return {
    firstName: parts[0],
    lastName: parts.slice(1).join(' '),
    confidence,
    needsReview: parts.length > 2  // Middle names = human should verify
  };
}

// Test cases that MUST pass:
// "John Smith" -> { first: "John", last: "Smith", confidence: 0.9 }
// "Mary O'Brien" -> { first: "Mary", last: "O'Brien", confidence: 0.9 }
// "JosÃ© GarcÃ­a" -> { first: "JosÃ©", last: "GarcÃ­a", confidence: 0.9 }
// "MarÃ­a del Carmen" -> { first: "MarÃ­a", last: "del Carmen", confidence: 0.7, needsReview: true }
// "Jean-Pierre Dupont" -> { first: "Jean-Pierre", last: "Dupont", confidence: 0.9 }
// "John Smith Jr" -> { first: "John", last: "Smith Jr", confidence: 0.85 }
```

```typescript
// phone_parser.ts - Handle US formats, flag international

interface ParsedPhone {
  normalized: string;  // Just digits
  formatted: string;   // (843) 555-1234
  confidence: number;
  isInternational: boolean;
}

function parsePhone(raw: string): ParsedPhone | null {
  // Extract all digits
  const digits = raw.replace(/\D/g, '');
  
  // US format: 10 digits or 11 starting with 1
  if (digits.length === 10) {
    return {
      normalized: digits,
      formatted: `(${digits.slice(0,3)}) ${digits.slice(3,6)}-${digits.slice(6)}`,
      confidence: 0.95,
      isInternational: false
    };
  }
  
  if (digits.length === 11 && digits[0] === '1') {
    const local = digits.slice(1);
    return {
      normalized: local,
      formatted: `(${local.slice(0,3)}) ${local.slice(3,6)}-${local.slice(6)}`,
      confidence: 0.95,
      isInternational: false
    };
  }
  
  // International or invalid - store raw, flag for review
  if (digits.length >= 7) {
    return {
      normalized: digits,
      formatted: raw.trim(),  // Keep original formatting
      confidence: 0.5,
      isInternational: true
    };
  }
  
  return null;  // Not enough digits to be a phone number
}
```

---

# MODULE 4: NLP PARSING (Chrono.js + Negation)

**Problem:** "Not Monday" parsed as Monday
**Solution:** Use Chrono.js for time parsing, add negation detection

```typescript
// availability_parser.ts

import * as chrono from 'chrono-node';

interface AvailabilityBlock {
  days: DayCode[];
  startTime: string;  // "HH:MM"
  endTime: string;
  isNegated: boolean;  // true = NOT available at this time
  confidence: number;
}

type DayCode = 'M' | 'T' | 'W' | 'TH' | 'F' | 'SA' | 'SU';

function parseAvailability(text: string, referenceDate: Date = new Date()): AvailabilityBlock[] {
  const lower = text.toLowerCase();
  const blocks: AvailabilityBlock[] = [];
  
  // Step 1: Detect negation patterns
  const negationPatterns = [
    /not\s+(on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/gi,
    /except\s+(on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/gi,
    /(busy|unavailable|cant|can't)\s+(on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/gi,
    /(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:doesn't|doesn't|won't|wont)\s+work/gi,
  ];
  
  const negatedDays = new Set<string>();
  for (const pattern of negationPatterns) {
    let match;
    while ((match = pattern.exec(lower)) !== null) {
      const dayMatch = match[0].match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/i);
      if (dayMatch) {
        negatedDays.add(dayMatch[0].toLowerCase());
      }
    }
  }
  
  // Step 2: Use Chrono.js for temporal expressions
  const chronoResults = chrono.parse(text, referenceDate);
  
  for (const result of chronoResults) {
    const days = extractDaysFromChronoResult(result);
    const timeRange = extractTimeRange(result);
    
    if (days.length > 0) {
      blocks.push({
        days,
        startTime: timeRange.start,
        endTime: timeRange.end,
        isNegated: false,
        confidence: 0.85
      });
    }
  }
  
  // Step 3: Fall back to keyword matching for simple cases
  if (blocks.length === 0) {
    const keywordBlocks = parseWithKeywords(lower, negatedDays);
    blocks.push(...keywordBlocks);
  }
  
  // Step 4: Mark negated blocks
  for (const block of blocks) {
    for (const day of block.days) {
      const dayName = dayCodeToName(day).toLowerCase();
      if (negatedDays.has(dayName)) {
        block.isNegated = true;
      }
    }
  }
  
  // Step 5: Invert if entire response is about availability (not negation)
  // "I'm free Monday and Tuesday" - these are POSITIVE
  // "I'm busy Monday" - Monday is NEGATIVE
  // Default: if no negation words found, treat as positive availability
  
  return blocks;
}

function parseWithKeywords(text: string, negatedDays: Set<string>): AvailabilityBlock[] {
  const blocks: AvailabilityBlock[] = [];
  
  // Day patterns
  const dayMap: Record<string, DayCode[]> = {
    'monday': ['M'], 'mon': ['M'],
    'tuesday': ['T'], 'tue': ['T'], 'tues': ['T'],
    'wednesday': ['W'], 'wed': ['W'],
    'thursday': ['TH'], 'thu': ['TH'], 'thur': ['TH'], 'thurs': ['TH'],
    'friday': ['F'], 'fri': ['F'],
    'saturday': ['SA'], 'sat': ['SA'],
    'sunday': ['SU'], 'sun': ['SU'],
    'weekday': ['M', 'T', 'W', 'TH', 'F'],
    'weekdays': ['M', 'T', 'W', 'TH', 'F'],
    'weekend': ['SA', 'SU'],
    'weekends': ['SA', 'SU'],
    'everyday': ['M', 'T', 'W', 'TH', 'F', 'SA', 'SU'],
    'mwf': ['M', 'W', 'F'],
    'tth': ['T', 'TH'], 'tr': ['T', 'TH'],
  };
  
  // Time patterns
  const timeMap: Record<string, { start: string; end: string }> = {
    'morning': { start: '08:00', end: '12:00' },
    'mornings': { start: '08:00', end: '12:00' },
    'afternoon': { start: '12:00', end: '17:00' },
    'afternoons': { start: '12:00', end: '17:00' },
    'evening': { start: '17:00', end: '21:00' },
    'evenings': { start: '17:00', end: '21:00' },
    'night': { start: '19:00', end: '23:00' },
    'nights': { start: '19:00', end: '23:00' },
    'lunch': { start: '11:00', end: '14:00' },
    'anytime': { start: '08:00', end: '22:00' },
    'whenever': { start: '08:00', end: '22:00' },
  };
  
  // Find days
  let foundDays: DayCode[] = [];
  for (const [pattern, days] of Object.entries(dayMap)) {
    if (text.includes(pattern)) {
      foundDays.push(...days);
    }
  }
  foundDays = [...new Set(foundDays)];  // Dedupe
  
  // Find times
  let timeRange = { start: CONFIG.parsing.default_available_start, end: CONFIG.parsing.default_available_end };
  for (const [pattern, range] of Object.entries(timeMap)) {
    if (text.includes(pattern)) {
      timeRange = range;
      break;
    }
  }
  
  // Handle "after X" pattern
  const afterMatch = text.match(/after\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i);
  if (afterMatch) {
    let hour = parseInt(afterMatch[1]);
    const ampm = afterMatch[3]?.toLowerCase();
    
    // Smart AM/PM inference
    if (ampm === 'pm' && hour < 12) hour += 12;
    else if (ampm === 'am') { /* keep as is */ }
    else if (hour < 7) hour += 12;  // "after 2" probably means 2pm
    
    timeRange.start = `${hour.toString().padStart(2, '0')}:00`;
    timeRange.end = CONFIG.parsing.default_available_end;
  }
  
  // Handle "before X" pattern
  const beforeMatch = text.match(/before\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i);
  if (beforeMatch) {
    let hour = parseInt(beforeMatch[1]);
    const ampm = beforeMatch[3]?.toLowerCase();
    
    if (ampm === 'pm' && hour < 12) hour += 12;
    
    timeRange.start = CONFIG.parsing.default_available_start;
    timeRange.end = `${hour.toString().padStart(2, '0')}:00`;
  }
  
  // Default days if none found
  if (foundDays.length === 0) {
    foundDays = ['M', 'T', 'W', 'TH', 'F'];  // Weekdays
  }
  
  blocks.push({
    days: foundDays,
    startTime: timeRange.start,
    endTime: timeRange.end,
    isNegated: false,
    confidence: 0.7
  });
  
  return blocks;
}

function dayCodeToName(code: DayCode): string {
  const map: Record<DayCode, string> = {
    'M': 'monday', 'T': 'tuesday', 'W': 'wednesday',
    'TH': 'thursday', 'F': 'friday', 'SA': 'saturday', 'SU': 'sunday'
  };
  return map[code];
}

// Convert parsed availability to positive availability blocks
// (removing negated times)
function computeAvailableBlocks(parsed: AvailabilityBlock[]): AvailabilityBlock[] {
  const positive = parsed.filter(b => !b.isNegated);
  const negative = parsed.filter(b => b.isNegated);
  
  // If we have positive blocks, use them (subtract negatives if any)
  // If we only have negatives, invert them
  
  if (positive.length > 0) {
    // TODO: Subtract negative blocks from positive blocks
    // For MVP, just return positive blocks
    return positive;
  }
  
  // Only negatives: invert to get availability
  // "Not Monday" -> available T, W, TH, F, SA, SU
  const allDays: DayCode[] = ['M', 'T', 'W', 'TH', 'F', 'SA', 'SU'];
  const negatedDaySet = new Set<DayCode>();
  
  for (const block of negative) {
    for (const day of block.days) {
      negatedDaySet.add(day);
    }
  }
  
  const availableDays = allDays.filter(d => !negatedDaySet.has(d));
  
  if (availableDays.length > 0) {
    return [{
      days: availableDays,
      startTime: CONFIG.parsing.default_available_start,
      endTime: CONFIG.parsing.default_available_end,
      isNegated: false,
      confidence: 0.6  // Lower confidence for inverted
    }];
  }
  
  return [];
}
```

---

# MODULE 5: SIMPLIFIED HOMOLOGY

**Problem:** Unused Mayer-Vietoris complexity, direct h1() called anyway
**Solution:** Keep what works, remove pretense

```typescript
// community_analysis.ts

interface CommunityMetrics {
  // Core Betti numbers
  components: number;      // Î²â‚€ - number of disconnected groups
  structuralHoles: number; // Î²â‚ - cycles (friend groups with gaps)
  
  // Normalized (by community size)
  normalizedHoles: number; // Î²â‚ / (n * factor)
  
  // Actionable
  isolationRisk: string[];     // Resident IDs at boundary
  bridgeResidents: string[];   // Resident IDs connecting groups
  
  // Health score
  healthScore: number;  // 0-100
  healthBreakdown: {
    connectivity: number;   // Based on Î²â‚€
    cohesion: number;       // Based on Î²â‚
    isolation: number;      // Based on boundary count
  };
  
  // Explanation (what the numbers mean)
  explanation: string;
}

function analyzeCommmunity(residents: Resident[], connections: Connection[]): CommunityMetrics {
  const n = residents.length;
  const e = connections.length;
  
  // Î²â‚€: Connected components (Union-Find)
  const components = countComponents(residents, connections);
  
  // Î²â‚: For graphs, Î²â‚ = |E| - |V| + Î²â‚€
  // This IS the correct formula. No need for chain complexes.
  const structuralHoles = Math.max(0, e - n + components);
  
  // Size-normalized: larger communities naturally have more cycles
  const normalizedHoles = n > 0 
    ? structuralHoles / (n * CONFIG.community.cycle_normalization_factor)
    : 0;
  
  // Boundary residents: bottom percentile by connection count
  const degrees = computeDegrees(residents, connections);
  const sortedByDegree = [...residents].sort((a, b) => 
    (degrees.get(a.id) || 0) - (degrees.get(b.id) || 0)
  );
  const boundaryCount = Math.ceil(n * CONFIG.community.boundary_percentile);
  const isolationRisk = sortedByDegree.slice(0, boundaryCount).map(r => r.id);
  
  // Bridge residents: in multiple subcommunities AND connected to different groups
  const bridgeResidents = findBridges(residents, connections);
  
  // Health score
  const connectivity = Math.max(0, 100 - (components - 1) * 20);  // Ideal: 1 component
  const cohesion = Math.max(0, 100 - normalizedHoles * 10);
  const isolationScore = Math.max(0, 100 - (isolationRisk.length / n) * 200);
  
  const weights = CONFIG.community.health_weights;
  const healthScore = 
    connectivity * weights.connectivity +
    cohesion * weights.cohesion +
    isolationScore * weights.isolation;
  
  // Plain English explanation
  const explanation = generateExplanation(components, structuralHoles, isolationRisk.length, n);
  
  return {
    components,
    structuralHoles,
    normalizedHoles,
    isolationRisk,
    bridgeResidents,
    healthScore,
    healthBreakdown: { connectivity, cohesion, isolation: isolationScore },
    explanation
  };
}

function generateExplanation(
  components: number, 
  holes: number, 
  isolatedCount: number, 
  total: number
): string {
  const lines: string[] = [];
  
  if (components === 1) {
    lines.push("âœ“ Everyone is connected to the same community.");
  } else {
    lines.push(`âš  There are ${components} separate groups that don't interact.`);
  }
  
  if (holes === 0) {
    lines.push("âœ“ No structural gaps in the community.");
  } else if (holes <= 2) {
    lines.push(`â„¹ ${holes} friend group(s) could benefit from more connectors.`);
  } else {
    lines.push(`âš  ${holes} structural gaps detected. Consider targeted introductions.`);
  }
  
  if (isolatedCount === 0) {
    lines.push("âœ“ No residents at high isolation risk.");
  } else {
    const pct = Math.round(isolatedCount / total * 100);
    lines.push(`âš  ${isolatedCount} residents (${pct}%) are on the edge of the community.`);
  }
  
  return lines.join('\n');
}

function countComponents(residents: Resident[], connections: Connection[]): number {
  // Union-Find
  const parent = new Map<string, string>();
  residents.forEach(r => parent.set(r.id, r.id));
  
  const find = (x: string): string => {
    if (parent.get(x) !== x) {
      parent.set(x, find(parent.get(x)!));
    }
    return parent.get(x)!;
  };
  
  const union = (a: string, b: string) => {
    parent.set(find(a), find(b));
  };
  
  for (const c of connections) {
    union(c.source, c.target);
  }
  
  const roots = new Set<string>();
  residents.forEach(r => roots.add(find(r.id)));
  
  return roots.size;
}

function computeDegrees(residents: Resident[], connections: Connection[]): Map<string, number> {
  const degrees = new Map<string, number>();
  residents.forEach(r => degrees.set(r.id, 0));
  
  for (const c of connections) {
    degrees.set(c.source, (degrees.get(c.source) || 0) + 1);
    degrees.set(c.target, (degrees.get(c.target) || 0) + 1);
  }
  
  return degrees;
}

function findBridges(residents: Resident[], connections: Connection[]): string[] {
  // Simplified: residents with connections to multiple subcommunities
  const bridges: string[] = [];
  
  for (const r of residents) {
    if (r.subcommunities.size < 2) continue;
    
    // Check if they actually connect to different subcommunities
    const connectedSubs = new Set<string>();
    for (const c of connections) {
      const neighborId = c.source === r.id ? c.target : c.source;
      if (neighborId === r.id) continue;
      
      const neighbor = residents.find(res => res.id === neighborId);
      if (neighbor) {
        neighbor.subcommunities.forEach(s => connectedSubs.add(s));
      }
    }
    
    if (connectedSubs.size >= 2) {
      bridges.push(r.id);
    }
  }
  
  return bridges;
}
```

---

# MODULE 6: SCHEDULING WITH FALLBACK

**Problem:** Greedy leaves people unscheduled with no explanation
**Solution:** Multiple passes + explanation + manual queue

```typescript
// scheduler.ts

interface ScheduleResult {
  scheduled: ScheduledSlot[];
  unscheduled: UnscheduledResident[];
  stats: {
    total: number;
    scheduled: number;
    unscheduledCount: number;
    batchEfficiency: number;  // Avg residents per slot
  };
}

interface UnscheduledResident {
  residentId: string;
  reason: SchedulingFailureReason;
  suggestion: string;
}

type SchedulingFailureReason = 
  | 'no_availability_provided'
  | 'no_overlap_with_ra'
  | 'all_slots_full'
  | 'schedule_conflict';

function scheduleCheckIns(
  residents: Resident[],
  raAvailability: TimeBlock[],
  config: SchedulingConfig
): ScheduleResult {
  const scheduled: ScheduledSlot[] = [];
  const unscheduled: UnscheduledResident[] = [];
  
  // Sort by priority (isolation risk first)
  const prioritized = prioritizeResidents(residents);
  
  // Generate all possible time slots from RA availability
  const slots = generateTimeSlots(raAvailability, config);
  
  // Multi-pass greedy (try different orderings)
  let bestSchedule = runGreedyPass(prioritized, slots, config);
  
  for (let pass = 1; pass < CONFIG.scheduling.greedy_passes; pass++) {
    // Shuffle unscheduled and try again
    const shuffled = shuffleArray([...prioritized]);
    const altSchedule = runGreedyPass(shuffled, slots, config);
    
    if (altSchedule.scheduled.length > bestSchedule.scheduled.length) {
      bestSchedule = altSchedule;
    }
  }
  
  // Process results
  const scheduledIds = new Set(bestSchedule.scheduled.flatMap(s => s.residentIds));
  
  for (const r of residents) {
    if (!scheduledIds.has(r.id)) {
      unscheduled.push({
        residentId: r.id,
        reason: determineFailureReason(r, raAvailability, bestSchedule.scheduled),
        suggestion: generateSuggestion(r, raAvailability)
      });
    }
  }
  
  return {
    scheduled: bestSchedule.scheduled,
    unscheduled,
    stats: {
      total: residents.length,
      scheduled: scheduledIds.size,
      unscheduledCount: unscheduled.length,
      batchEfficiency: bestSchedule.scheduled.length > 0
        ? scheduledIds.size / bestSchedule.scheduled.length
        : 0
    }
  };
}

function determineFailureReason(
  resident: Resident,
  raAvailability: TimeBlock[],
  scheduled: ScheduledSlot[]
): SchedulingFailureReason {
  // No availability data
  if (!resident.statedAvailability || resident.statedAvailability.length === 0) {
    return 'no_availability_provided';
  }
  
  // Check if any overlap with RA
  const hasOverlap = resident.statedAvailability.some(ra =>
    raAvailability.some(ra2 => blocksOverlap(ra, ra2))
  );
  
  if (!hasOverlap) {
    return 'no_overlap_with_ra';
  }
  
  // Slots exist but full
  return 'all_slots_full';
}

function generateSuggestion(resident: Resident, raAvailability: TimeBlock[]): string {
  if (!resident.statedAvailability || resident.statedAvailability.length === 0) {
    return "Please provide your availability by replying to the check-in text.";
  }
  
  // Find RA's available times that don't match resident
  const raDays = new Set(raAvailability.map(b => b.day));
  const resDays = new Set(resident.statedAvailability.flatMap(b => b.days));
  
  const missingDays = [...raDays].filter(d => !resDays.has(d as any));
  
  if (missingDays.length > 0) {
    const dayNames = missingDays.map(d => dayCodeToName(d as DayCode)).join(', ');
    return `Are you available on ${dayNames}? Those times work better for scheduling.`;
  }
  
  return "We'll reach out to find a time that works. Reply 'reschedule' if you have new availability.";
}

function prioritizeResidents(residents: Resident[]): Resident[] {
  const weights = CONFIG.scheduling.priority_weights;
  
  return [...residents].sort((a, b) => {
    const scoreA = computePriorityScore(a, weights);
    const scoreB = computePriorityScore(b, weights);
    return scoreB - scoreA;  // Higher priority first
  });
}

function computePriorityScore(resident: Resident, weights: typeof CONFIG.scheduling.priority_weights): number {
  let score = 50;  // Base
  
  if (resident.isIsolationRisk) score += weights.isolation_risk;
  if (resident.inFragileGroup) score += weights.fragile_group;
  if (resident.lastRating && resident.lastRating <= 2) score += weights.low_rating;
  if (resident.followUpNeeded) score += weights.follow_up_needed;
  if (resident.isBridge) score += weights.bridge_resident;
  if (resident.inStableGroup) score += weights.stable_group;  // Negative weight
  
  return score;
}
```

---

# MODULE 7: CSV FALLBACK

**Problem:** OCR fails, user stuck
**Solution:** Always offer CSV upload

```typescript
// csv_import.ts

import Papa from 'papaparse';

interface CSVImportResult {
  residents: Resident[];
  warnings: string[];
  columnMapping: Record<string, string>;  // CSV header -> our field
}

async function importCSV(file: File): Promise<Result<CSVImportResult, ParseError>> {
  return new Promise((resolve) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        if (results.errors.length > 0) {
          resolve(Err({
            code: 'INVALID_FORMAT',
            message: `CSV parsing error: ${results.errors[0].message}`,
            suggestion: 'Check that the file is a valid CSV with headers'
          }));
          return;
        }
        
        const mapping = detectColumnMapping(results.meta.fields || []);
        const residents: Resident[] = [];
        const warnings: string[] = [];
        
        for (let i = 0; i < results.data.length; i++) {
          const row = results.data[i] as Record<string, string>;
          const resident = parseCSVRow(row, mapping, i + 2);  // +2 for header + 1-indexed
          
          if (resident.ok) {
            residents.push(resident.value);
          } else {
            warnings.push(`Row ${i + 2}: ${resident.error.message}`);
          }
        }
        
        resolve(Ok({ residents, warnings, columnMapping: mapping }));
      },
      error: (error) => {
        resolve(Err({
          code: 'INVALID_FORMAT',
          message: error.message,
          suggestion: 'Ensure the file is a valid CSV'
        }));
      }
    });
  });
}

function detectColumnMapping(headers: string[]): Record<string, string> {
  const mapping: Record<string, string> = {};
  
  const patterns: Record<string, RegExp[]> = {
    firstName: [/first\s*name/i, /fname/i, /given\s*name/i],
    lastName: [/last\s*name/i, /lname/i, /surname/i, /family\s*name/i],
    name: [/^name$/i, /full\s*name/i, /student\s*name/i, /resident\s*name/i],
    room: [/room/i, /room\s*#/i, /room\s*number/i, /unit/i],
    email: [/email/i, /e-mail/i, /mail/i],
    phone: [/phone/i, /cell/i, /mobile/i, /tel/i],
  };
  
  for (const header of headers) {
    for (const [field, regexes] of Object.entries(patterns)) {
      if (regexes.some(r => r.test(header))) {
        mapping[header] = field;
        break;
      }
    }
  }
  
  return mapping;
}

function parseCSVRow(
  row: Record<string, string>, 
  mapping: Record<string, string>,
  rowNum: number
): Result<Resident, ParseError> {
  const getValue = (field: string): string | undefined => {
    for (const [csvCol, ourField] of Object.entries(mapping)) {
      if (ourField === field) {
        return row[csvCol]?.trim();
      }
    }
    return undefined;
  };
  
  // Handle combined name field
  let firstName = getValue('firstName');
  let lastName = getValue('lastName');
  
  if (!firstName && !lastName) {
    const fullName = getValue('name');
    if (fullName) {
      const parsed = parseName(fullName);
      firstName = parsed.firstName;
      lastName = parsed.lastName;
    }
  }
  
  const room = getValue('room');
  
  if (!firstName || !room) {
    return Err({
      code: 'MISSING_FIELD',
      message: `Missing required field: ${!firstName ? 'name' : 'room'}`,
      field: !firstName ? 'name' : 'room'
    });
  }
  
  return Ok({
    id: crypto.randomUUID(),
    firstName,
    lastName: lastName || '',
    room,
    email: getValue('email') || '',
    phone: getValue('phone') || '',
    // ... other fields with defaults
  });
}
```

---

# BUILD ORDER

```
PHASE 1: Foundation (MUST HAVE for any demo)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ config.ts - All thresholds externalized
â–¡ result.ts - Error handling types
â–¡ name_parser.ts - Unicode-safe name parsing
â–¡ phone_parser.ts - Phone normalization
â–¡ csv_import.ts - CSV fallback
â–¡ csv_column_detector.ts - Enhanced column detection (Module 11)

PHASE 2: Core Parsing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ ocr_service.ts - Tesseract wrapper with timeout/retry
â–¡ availability_parser.ts - Chrono.js + negation detection
â–¡ roster_upload.tsx - UI with fallback options
â–¡ confidence_display.tsx - Explicit confidence UI (Module 9)

PHASE 3: Analysis
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ community_analysis.ts - Simplified homology
â–¡ priority_service.ts - Check-in ordering
â–¡ introduction_suggester.ts - Fill structural holes

PHASE 4: Scheduling
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ scheduler.ts - Multi-pass greedy with explanations
â–¡ reminder_service.ts - Day-of notifications
â–¡ calendar_view.tsx - Visual schedule

PHASE 5: Polish & Validation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ health_dashboard.tsx - Community metrics display
â–¡ explanation_panel.tsx - What the numbers mean
â–¡ manual_override.tsx - Human in the loop
â–¡ calibration.ts - OCR threshold calibration (Module 8)

PHASE 6: Testing (NEW - Required before production)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ tests/name_parser.test.ts - Unit tests for name parsing
â–¡ tests/phone_parser.test.ts - Unit tests for phone parsing
â–¡ tests/availability_parser.test.ts - Unit tests with negation handling
â–¡ tests/scheduler.test.ts - Scheduling logic tests
â–¡ tests/community_analysis.test.ts - Homology calculation tests
â–¡ tests/csv_import.test.ts - Integration tests for CSV import
â–¡ tests/test_utils.ts - Mock data generators
```

---

# WHAT WE REMOVED (And Why It's Fine)

| Removed | Why It's Fine |
|---------|---------------|
| Full Mayer-Vietoris exact sequence | Direct Î²â‚ = E - V + Î²â‚€ IS correct for graphs |
| ILP scheduling | Greedy + multi-pass works for n < 100 |
| RFC 5322 email validation | @school.edu is sufficient |
| ML-based NLP | Chrono.js + negation keywords handles 95% of cases |
| Learned connection weights | Heuristics work, calibrate in v3 with real data |
| Dynamic epsilon | 1e-10 is fine for community-sized matrices |

---

# WHAT WE KEPT (And Why It Matters)

| Kept | Why It Matters |
|------|----------------|
| Unicode name parsing | Real people have apostrophes and accents |
| Negation detection | "Not Monday" must not schedule Monday |
| CSV fallback | OCR will fail, user needs escape hatch |
| Confidence scores | User knows what to review |
| Externalized config | No code changes needed to tune thresholds |
| Explanation strings | User understands what the math means |
| Multi-pass scheduling | Catches cases greedy misses |
| Unscheduled reasons | User knows WHY someone wasn't scheduled |

# NEW ADDITIONS (Addressing Weaknesses)

| Addition | Module | Why It Matters |
|----------|--------|----------------|
| OCR Calibration Utility | Module 8 | Validates 0.7 threshold with real data |
| Confidence Score UI | Module 9 | Shows scores explicitly in review screens |
| Testing Roadmap | Module 10 | Explicit test coverage requirements |
| CSV Column Mismatch Handling | Module 11 | Graceful fallback when headers don't match |
| Known Format Detection | Module 11 | Auto-detects Banner, StarRez, RMS, Symplicity |
| Manual Mapping UI | Module 11 | User can map columns when auto-detect fails |

---

**This is a tool that works, not a research prototype that impresses.**

---

# MODULE 8: OCR THRESHOLD CALIBRATION

**Problem:** 0.7 threshold is arbitrary, no validation dataset
**Solution:** Calibration utility with labeled test samples

```typescript
// calibration.ts - Threshold Calibration Utility

interface CalibrationSample {
  imageFile: string;
  expectedResidents: Resident[];  // Ground truth
  ocrResult?: ParsedRoster;       // Actual output
  ocrConfidence?: number;         // Tesseract confidence
}

interface CalibrationResult {
  samples: CalibrationSample[];
  metrics: CalibrationMetrics;
  recommendedThreshold: number;
  thresholdAnalysis: ThresholdAnalysis[];
}

interface CalibrationMetrics {
  totalSamples: number;
  correctlyParsed: number;
  falsePositives: number;    // Low confidence but parsed correctly
  falseNegatives: number;    // High confidence but parsed incorrectly
  precision: number;         // TP / (TP + FP)
  recall: number;            // TP / (TP + FN)
  f1Score: number;           // 2 * (P * R) / (P + R)
}

interface ThresholdAnalysis {
  threshold: number;         // 0.5, 0.6, 0.7, 0.8, 0.9
  accepted: number;          // Samples above threshold
  rejected: number;          // Samples below threshold
  acceptedCorrect: number;   // Above threshold AND correct
  rejectedCorrect: number;   // Below threshold BUT correct (false rejects)
  precision: number;
  recall: number;
  f1Score: number;
}

// ============================================================================
// CALIBRATION RUNNER
// ============================================================================

async function runCalibration(
  samples: CalibrationSample[]
): Promise<CalibrationResult> {

  // Step 1: Run OCR on all samples
  for (const sample of samples) {
    const result = await processRosterImage(sample.imageFile);
    if (result.ok) {
      sample.ocrResult = result.value;
      sample.ocrConfidence = result.value.confidence;
    } else {
      sample.ocrConfidence = 0;
    }
  }

  // Step 2: Evaluate at multiple thresholds
  const thresholds = [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9];
  const analyses: ThresholdAnalysis[] = [];

  for (const threshold of thresholds) {
    const analysis = analyzeAtThreshold(samples, threshold);
    analyses.push(analysis);
  }

  // Step 3: Find optimal threshold (maximize F1)
  const optimal = analyses.reduce((best, curr) =>
    curr.f1Score > best.f1Score ? curr : best
  );

  // Step 4: Compute overall metrics at current threshold
  const currentMetrics = computeMetrics(samples, CONFIG.parsing.ocr_confidence_threshold);

  return {
    samples,
    metrics: currentMetrics,
    recommendedThreshold: optimal.threshold,
    thresholdAnalysis: analyses
  };
}

function analyzeAtThreshold(
  samples: CalibrationSample[],
  threshold: number
): ThresholdAnalysis {
  let accepted = 0, rejected = 0;
  let acceptedCorrect = 0, rejectedCorrect = 0;

  for (const sample of samples) {
    const conf = sample.ocrConfidence || 0;
    const isCorrect = verifyParsedResult(sample.ocrResult, sample.expectedResidents);

    if (conf >= threshold) {
      accepted++;
      if (isCorrect) acceptedCorrect++;
    } else {
      rejected++;
      if (isCorrect) rejectedCorrect++;  // False reject
    }
  }

  const truePositives = acceptedCorrect;
  const falsePositives = accepted - acceptedCorrect;
  const falseNegatives = rejectedCorrect;  // Correct but rejected

  const precision = accepted > 0 ? truePositives / accepted : 0;
  const recall = (truePositives + falseNegatives) > 0
    ? truePositives / (truePositives + falseNegatives) : 0;
  const f1Score = (precision + recall) > 0
    ? 2 * precision * recall / (precision + recall) : 0;

  return {
    threshold,
    accepted,
    rejected,
    acceptedCorrect,
    rejectedCorrect,
    precision,
    recall,
    f1Score
  };
}

function verifyParsedResult(
  parsed: ParsedRoster | undefined,
  expected: Resident[]
): boolean {
  if (!parsed) return false;

  // Check name match rate
  const expectedNames = new Set(expected.map(r =>
    `${r.firstName.toLowerCase()} ${r.lastName.toLowerCase()}`
  ));

  let matches = 0;
  for (const resident of parsed.residents) {
    const name = `${resident.firstName.toLowerCase()} ${resident.lastName.toLowerCase()}`;
    if (expectedNames.has(name)) matches++;
  }

  // Consider correct if 90%+ names match
  const matchRate = expected.length > 0 ? matches / expected.length : 0;
  return matchRate >= 0.9;
}

// ============================================================================
// CALIBRATION UI COMPONENT
// ============================================================================

function CalibrationDashboard() {
  const [result, setResult] = useState<CalibrationResult | null>(null);
  const [samples, setSamples] = useState<CalibrationSample[]>([]);

  return (
    <div className="calibration-dashboard">
      <h2>OCR Threshold Calibration</h2>

      {/* Sample upload */}
      <section className="sample-upload">
        <h3>1. Upload Validation Dataset</h3>
        <p className="help-text">
          Upload roster images with known correct data to calibrate OCR threshold.
        </p>
        <input
          type="file"
          multiple
          accept="image/*"
          onChange={(e) => handleSampleUpload(e.target.files)}
        />
        <p className="sample-count">{samples.length} samples loaded</p>
      </section>

      {/* Run calibration */}
      <section className="run-calibration">
        <h3>2. Run Calibration</h3>
        <button
          onClick={() => runCalibration(samples).then(setResult)}
          disabled={samples.length < 5}
        >
          Run Calibration ({samples.length} samples)
        </button>
        {samples.length < 5 && (
          <p className="warning">Minimum 5 samples required for meaningful calibration</p>
        )}
      </section>

      {/* Results */}
      {result && (
        <section className="calibration-results">
          <h3>3. Results</h3>

          {/* Current vs Recommended */}
          <div className="threshold-comparison">
            <div className="current">
              <h4>Current Threshold</h4>
              <span className="value">{CONFIG.parsing.ocr_confidence_threshold}</span>
              <span className="metrics">
                F1: {(result.metrics.f1Score * 100).toFixed(1)}%
              </span>
            </div>
            <div className="recommended">
              <h4>Recommended Threshold</h4>
              <span className="value">{result.recommendedThreshold}</span>
              <span className="metrics">
                F1: {(result.thresholdAnalysis.find(
                  a => a.threshold === result.recommendedThreshold
                )?.f1Score || 0 * 100).toFixed(1)}%
              </span>
            </div>
          </div>

          {/* Threshold curve */}
          <div className="threshold-curve">
            <h4>Threshold Analysis</h4>
            <table>
              <thead>
                <tr>
                  <th>Threshold</th>
                  <th>Accepted</th>
                  <th>Precision</th>
                  <th>Recall</th>
                  <th>F1 Score</th>
                </tr>
              </thead>
              <tbody>
                {result.thresholdAnalysis.map(a => (
                  <tr key={a.threshold} className={
                    a.threshold === result.recommendedThreshold ? 'recommended' : ''
                  }>
                    <td>{a.threshold}</td>
                    <td>{a.accepted}/{result.samples.length}</td>
                    <td>{(a.precision * 100).toFixed(1)}%</td>
                    <td>{(a.recall * 100).toFixed(1)}%</td>
                    <td>{(a.f1Score * 100).toFixed(1)}%</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Apply button */}
          <button
            className="apply-threshold"
            onClick={() => applyThreshold(result.recommendedThreshold)}
          >
            Apply Recommended Threshold ({result.recommendedThreshold})
          </button>
        </section>
      )}
    </div>
  );
}

// CALIBRATE comment for default value
// Current: 0.7 - industry standard starting point
// After calibration with your institution's data:
// - Higher (0.8+): More accurate but more manual review
// - Lower (0.6-): Faster processing but more errors slip through
// Recommendation: Start at 0.7, run calibration with 20+ samples
```

---

# MODULE 9: CONFIDENCE SCORE UI DISPLAY

**Problem:** Confidence scores computed but not clearly shown to users
**Solution:** Explicit confidence indicators throughout the review UI

```typescript
// confidence_display.tsx - Explicit Confidence Score Components

// ============================================================================
// CONFIDENCE BADGE COMPONENT
// ============================================================================

interface ConfidenceBadgeProps {
  confidence: number;  // 0-1
  showLabel?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

function ConfidenceBadge({ confidence, showLabel = true, size = 'md' }: ConfidenceBadgeProps) {
  const level = getConfidenceLevel(confidence);
  const percentage = Math.round(confidence * 100);

  return (
    <div className={`confidence-badge confidence-${level} size-${size}`}>
      <div
        className="confidence-bar"
        style={{ width: `${percentage}%` }}
        aria-valuenow={percentage}
        aria-valuemin={0}
        aria-valuemax={100}
      />
      <span className="confidence-value">{percentage}%</span>
      {showLabel && (
        <span className="confidence-label">{level}</span>
      )}
    </div>
  );
}

function getConfidenceLevel(confidence: number): 'high' | 'medium' | 'low' | 'critical' {
  if (confidence >= 0.9) return 'high';
  if (confidence >= 0.7) return 'medium';
  if (confidence >= 0.5) return 'low';
  return 'critical';
}

// CSS for confidence badges
const confidenceStyles = `
.confidence-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-weight: 500;
}

.confidence-badge.confidence-high {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.confidence-badge.confidence-medium {
  background: #fff3cd;
  color: #856404;
  border: 1px solid #ffeeba;
}

.confidence-badge.confidence-low {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.confidence-badge.confidence-critical {
  background: #721c24;
  color: white;
  border: 1px solid #721c24;
}

.confidence-bar {
  height: 4px;
  background: currentColor;
  border-radius: 2px;
  min-width: 40px;
}
`;

// ============================================================================
// RESIDENT CARD WITH CONFIDENCE
// ============================================================================

interface ResidentCardProps {
  resident: Resident;
  nameConfidence: number;
  phoneConfidence?: number;
  overallConfidence: number;
  needsReview: boolean;
  onEdit: (field: string) => void;
}

function ResidentCard({
  resident,
  nameConfidence,
  phoneConfidence,
  overallConfidence,
  needsReview,
  onEdit
}: ResidentCardProps) {
  return (
    <div className={`resident-card ${needsReview ? 'needs-review' : ''}`}>
      {/* Overall confidence header */}
      <div className="card-header">
        <ConfidenceBadge confidence={overallConfidence} />
        {needsReview && (
          <span className="review-badge">âš ï¸ Needs Review</span>
        )}
      </div>

      {/* Name field with confidence */}
      <div className="field-row">
        <label>Name</label>
        <div className="field-value-group">
          <span className="field-value">
            {resident.firstName} {resident.lastName}
          </span>
          <ConfidenceBadge
            confidence={nameConfidence}
            size="sm"
            showLabel={false}
          />
          <button
            className="edit-btn"
            onClick={() => onEdit('name')}
            title="Edit name"
          >
            âœï¸
          </button>
        </div>
      </div>

      {/* Room field */}
      <div className="field-row">
        <label>Room</label>
        <span className="field-value">{resident.room}</span>
      </div>

      {/* Phone with confidence (if parsed) */}
      {resident.phone && (
        <div className="field-row">
          <label>Phone</label>
          <div className="field-value-group">
            <span className="field-value">{resident.phone}</span>
            {phoneConfidence !== undefined && (
              <ConfidenceBadge
                confidence={phoneConfidence}
                size="sm"
                showLabel={false}
              />
            )}
            <button
              className="edit-btn"
              onClick={() => onEdit('phone')}
              title="Edit phone"
            >
              âœï¸
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// ============================================================================
// OCR RESULTS REVIEW SCREEN
// ============================================================================

interface OCRReviewScreenProps {
  result: ParsedRoster;
  onConfirm: (residents: Resident[]) => void;
  onRetry: () => void;
}

function OCRReviewScreen({ result, onConfirm, onRetry }: OCRReviewScreenProps) {
  const [residents, setResidents] = useState(result.residents);

  // Count items needing review
  const needsReviewCount = residents.filter(r => r.needsReview).length;
  const lowConfidenceCount = residents.filter(r => r.confidence < 0.7).length;

  return (
    <div className="ocr-review-screen">
      {/* Header with overall confidence */}
      <header className="review-header">
        <h2>Review OCR Results</h2>

        {/* EXPLICIT CONFIDENCE SUMMARY */}
        <div className="confidence-summary">
          <div className="summary-item">
            <span className="label">OCR Confidence</span>
            <ConfidenceBadge confidence={result.confidence} size="lg" />
          </div>

          <div className="summary-item">
            <span className="label">Records Parsed</span>
            <span className="value">{residents.length}</span>
          </div>

          <div className="summary-item warning">
            <span className="label">Needs Review</span>
            <span className="value">{needsReviewCount}</span>
          </div>

          <div className="summary-item">
            <span className="label">Low Confidence</span>
            <span className="value">{lowConfidenceCount}</span>
          </div>
        </div>

        {/* Confidence explanation */}
        <div className="confidence-explanation">
          <h4>What do confidence scores mean?</h4>
          <ul>
            <li><strong>90%+:</strong> High confidence - likely correct</li>
            <li><strong>70-89%:</strong> Medium confidence - verify if possible</li>
            <li><strong>50-69%:</strong> Low confidence - needs human review</li>
            <li><strong>&lt;50%:</strong> Critical - likely errors, please verify</li>
          </ul>
        </div>
      </header>

      {/* Filter controls */}
      <div className="filter-controls">
        <button className="filter-btn active">
          All ({residents.length})
        </button>
        <button className="filter-btn">
          Needs Review ({needsReviewCount})
        </button>
        <button className="filter-btn">
          Low Confidence ({lowConfidenceCount})
        </button>
      </div>

      {/* Resident cards */}
      <div className="residents-grid">
        {residents.map((resident, idx) => (
          <ResidentCard
            key={idx}
            resident={resident}
            nameConfidence={resident.nameConfidence || 0.9}
            phoneConfidence={resident.phoneConfidence}
            overallConfidence={resident.confidence || 0.9}
            needsReview={resident.needsReview || false}
            onEdit={(field) => handleEdit(idx, field)}
          />
        ))}
      </div>

      {/* Action buttons */}
      <footer className="review-actions">
        <button className="btn-secondary" onClick={onRetry}>
          ğŸ”„ Re-scan Image
        </button>
        <button
          className="btn-primary"
          onClick={() => onConfirm(residents)}
          disabled={needsReviewCount > 0}
        >
          âœ“ Confirm {residents.length} Residents
        </button>
        {needsReviewCount > 0 && (
          <p className="action-hint">
            Review {needsReviewCount} flagged items before confirming
          </p>
        )}
      </footer>
    </div>
  );
}

// ============================================================================
// AVAILABILITY CONFIDENCE DISPLAY
// ============================================================================

function AvailabilityConfidenceView({ blocks }: { blocks: AvailabilityBlock[] }) {
  return (
    <div className="availability-confidence-view">
      <h4>Parsed Availability</h4>

      {blocks.map((block, idx) => (
        <div key={idx} className={`availability-block ${block.isNegated ? 'negated' : ''}`}>
          <div className="block-header">
            <span className="days">{block.days.join(', ')}</span>
            <span className="times">{block.startTime} - {block.endTime}</span>
            <ConfidenceBadge confidence={block.confidence} size="sm" />
          </div>

          {block.isNegated && (
            <span className="negation-badge">âŒ NOT available</span>
          )}

          {/* Confidence explanation for this block */}
          {block.confidence < 0.7 && (
            <p className="low-confidence-hint">
              âš ï¸ Lower confidence - please verify this time block
            </p>
          )}
        </div>
      ))}
    </div>
  );
}
```

---

# MODULE 10: TESTING ROADMAP

**Problem:** No explicit testing mentioned
**Solution:** Comprehensive testing strategy with example test cases

```typescript
// ============================================================================
// TESTING STRATEGY
// ============================================================================
//
// This module defines the testing approach for CheckIn v2.
// All tests should be implemented before shipping to production.
//
// Test Categories:
// 1. Unit Tests - Individual function behavior
// 2. Integration Tests - Component interactions
// 3. End-to-End Tests - Full workflow validation
// 4. Validation Tests - Data quality checks
//

// ============================================================================
// 1. UNIT TESTS: NAME PARSER
// ============================================================================

// tests/name_parser.test.ts
describe('parseName', () => {
  // Basic cases
  test('parses simple first last name', () => {
    const result = parseName('John Smith');
    expect(result).toEqual({
      firstName: 'John',
      lastName: 'Smith',
      confidence: 0.9,
      needsReview: false
    });
  });

  // Unicode handling
  test('preserves apostrophes in names', () => {
    const result = parseName("Mary O'Brien");
    expect(result.lastName).toBe("O'Brien");
    expect(result.confidence).toBeGreaterThanOrEqual(0.9);
  });

  test('handles Spanish names with accents', () => {
    const result = parseName('JosÃ© GarcÃ­a');
    expect(result.firstName).toBe('JosÃ©');
    expect(result.lastName).toBe('GarcÃ­a');
  });

  test('handles hyphenated names', () => {
    const result = parseName('Jean-Pierre Dupont');
    expect(result.firstName).toBe('Jean-Pierre');
    expect(result.lastName).toBe('Dupont');
  });

  // Edge cases
  test('flags single name for review', () => {
    const result = parseName('Madonna');
    expect(result.firstName).toBe('Madonna');
    expect(result.lastName).toBe('');
    expect(result.needsReview).toBe(true);
    expect(result.confidence).toBe(0.5);
  });

  test('handles suffixes correctly', () => {
    const result = parseName('John Smith Jr');
    expect(result.firstName).toBe('John');
    expect(result.lastName).toBe('Smith Jr');
  });

  test('flags multi-part names for review', () => {
    const result = parseName('MarÃ­a del Carmen');
    expect(result.needsReview).toBe(true);
    expect(result.confidence).toBe(0.7);
  });

  test('handles empty input', () => {
    const result = parseName('');
    expect(result.confidence).toBe(0);
    expect(result.needsReview).toBe(true);
  });
});

// ============================================================================
// 2. UNIT TESTS: PHONE PARSER
// ============================================================================

// tests/phone_parser.test.ts
describe('parsePhone', () => {
  test('parses 10-digit US number', () => {
    const result = parsePhone('8435551234');
    expect(result?.normalized).toBe('8435551234');
    expect(result?.formatted).toBe('(843) 555-1234');
    expect(result?.confidence).toBe(0.95);
    expect(result?.isInternational).toBe(false);
  });

  test('parses formatted US number', () => {
    const result = parsePhone('(843) 555-1234');
    expect(result?.normalized).toBe('8435551234');
  });

  test('parses 11-digit with leading 1', () => {
    const result = parsePhone('18435551234');
    expect(result?.normalized).toBe('8435551234');
  });

  test('flags international numbers', () => {
    const result = parsePhone('+44 20 7946 0958');
    expect(result?.isInternational).toBe(true);
    expect(result?.confidence).toBe(0.5);
  });

  test('returns null for too few digits', () => {
    const result = parsePhone('12345');
    expect(result).toBeNull();
  });
});

// ============================================================================
// 3. UNIT TESTS: AVAILABILITY PARSER
// ============================================================================

// tests/availability_parser.test.ts
describe('parseAvailability', () => {
  // Positive availability
  test('parses simple day availability', () => {
    const result = parseAvailability('Monday and Tuesday afternoons');
    expect(result[0].days).toContain('M');
    expect(result[0].days).toContain('T');
    expect(result[0].isNegated).toBe(false);
  });

  // CRITICAL: Negation handling
  test('detects "not Monday" as negated', () => {
    const result = parseAvailability('not Monday');
    const mondayBlock = result.find(b => b.days.includes('M'));
    expect(mondayBlock?.isNegated).toBe(true);
  });

  test('detects "except Tuesday" as negated', () => {
    const result = parseAvailability('available everyday except Tuesday');
    const tuesdayBlock = result.find(b => b.days.includes('T') && b.isNegated);
    expect(tuesdayBlock).toBeDefined();
  });

  test('detects "busy on Wednesday" as negated', () => {
    const result = parseAvailability("I'm busy on Wednesday");
    const wedBlock = result.find(b => b.days.includes('W'));
    expect(wedBlock?.isNegated).toBe(true);
  });

  // Time parsing
  test('parses "after 3pm" correctly', () => {
    const result = parseAvailability('available after 3pm');
    expect(result[0].startTime).toBe('15:00');
  });

  test('parses "before noon" correctly', () => {
    const result = parseAvailability('free before noon');
    expect(result[0].endTime).toBe('12:00');
  });

  // Inversion logic
  test('inverts negation-only input', () => {
    const parsed = parseAvailability('not Monday');
    const available = computeAvailableBlocks(parsed);

    expect(available[0].days).not.toContain('M');
    expect(available[0].days).toContain('T');
    expect(available[0].days).toContain('W');
  });
});

// ============================================================================
// 4. UNIT TESTS: SCHEDULING
// ============================================================================

// tests/scheduler.test.ts
describe('scheduleCheckIns', () => {
  const mockResidents = [
    { id: '1', statedAvailability: [{ days: ['M'], startTime: '09:00', endTime: '12:00' }] },
    { id: '2', statedAvailability: [{ days: ['M'], startTime: '10:00', endTime: '14:00' }] },
    { id: '3', statedAvailability: [] },  // No availability
  ];

  const mockRAAvailability = [
    { day: 'M', startTime: '09:00', endTime: '17:00' }
  ];

  test('schedules residents with overlapping availability', () => {
    const result = scheduleCheckIns(mockResidents, mockRAAvailability, {});
    expect(result.scheduled.length).toBeGreaterThan(0);
    expect(result.stats.scheduled).toBe(2);
  });

  test('reports unscheduled with correct reason', () => {
    const result = scheduleCheckIns(mockResidents, mockRAAvailability, {});
    const unscheduledRes3 = result.unscheduled.find(u => u.residentId === '3');
    expect(unscheduledRes3?.reason).toBe('no_availability_provided');
  });

  test('provides helpful suggestions for unscheduled', () => {
    const result = scheduleCheckIns(mockResidents, mockRAAvailability, {});
    const unscheduled = result.unscheduled[0];
    expect(unscheduled.suggestion).toBeDefined();
    expect(unscheduled.suggestion.length).toBeGreaterThan(0);
  });
});

// ============================================================================
// 5. UNIT TESTS: COMMUNITY ANALYSIS
// ============================================================================

// tests/community_analysis.test.ts
describe('analyzeCommmunity', () => {
  test('detects single connected component', () => {
    const residents = [{ id: '1' }, { id: '2' }, { id: '3' }];
    const connections = [
      { source: '1', target: '2' },
      { source: '2', target: '3' }
    ];
    const result = analyzeCommmunity(residents, connections);
    expect(result.components).toBe(1);
  });

  test('detects multiple components', () => {
    const residents = [{ id: '1' }, { id: '2' }, { id: '3' }, { id: '4' }];
    const connections = [
      { source: '1', target: '2' },
      { source: '3', target: '4' }
    ];
    const result = analyzeCommmunity(residents, connections);
    expect(result.components).toBe(2);
  });

  test('calculates structural holes correctly', () => {
    // Triangle: 3 vertices, 3 edges, 1 component
    // Î²â‚ = E - V + Î²â‚€ = 3 - 3 + 1 = 1
    const residents = [{ id: '1' }, { id: '2' }, { id: '3' }];
    const connections = [
      { source: '1', target: '2' },
      { source: '2', target: '3' },
      { source: '3', target: '1' }
    ];
    const result = analyzeCommmunity(residents, connections);
    expect(result.structuralHoles).toBe(1);
  });

  test('identifies isolation risk residents', () => {
    const residents = [
      { id: '1' }, { id: '2' }, { id: '3' }, { id: '4' }, { id: '5' }
    ];
    // Resident 5 has only 1 connection, others have 2
    const connections = [
      { source: '1', target: '2' },
      { source: '2', target: '3' },
      { source: '3', target: '4' },
      { source: '4', target: '1' },
      { source: '1', target: '5' }  // Resident 5 only connects to 1
    ];
    const result = analyzeCommmunity(residents, connections);
    expect(result.isolationRisk).toContain('5');
  });
});

// ============================================================================
// 6. INTEGRATION TESTS: CSV IMPORT
// ============================================================================

// tests/csv_import.test.ts
describe('CSV Import Integration', () => {
  test('detects standard column headers', async () => {
    const csv = `First Name,Last Name,Room Number,Email
John,Smith,101,john@school.edu
Jane,Doe,102,jane@school.edu`;

    const file = new File([csv], 'roster.csv', { type: 'text/csv' });
    const result = await importCSV(file);

    expect(result.ok).toBe(true);
    expect(result.value.residents.length).toBe(2);
  });

  test('handles combined name column', async () => {
    const csv = `Full Name,Room
John Smith,101
Jane Doe,102`;

    const file = new File([csv], 'roster.csv', { type: 'text/csv' });
    const result = await importCSV(file);

    expect(result.ok).toBe(true);
    expect(result.value.residents[0].firstName).toBe('John');
    expect(result.value.residents[0].lastName).toBe('Smith');
  });

  test('reports warnings for invalid rows', async () => {
    const csv = `Name,Room
John Smith,101
,102`;  // Missing name

    const file = new File([csv], 'roster.csv', { type: 'text/csv' });
    const result = await importCSV(file);

    expect(result.ok).toBe(true);
    expect(result.value.warnings.length).toBe(1);
    expect(result.value.warnings[0]).toContain('Row 3');
  });
});

// ============================================================================
// 7. TEST UTILITIES
// ============================================================================

// tests/test_utils.ts
export function createMockResident(overrides: Partial<Resident> = {}): Resident {
  return {
    id: crypto.randomUUID(),
    firstName: 'Test',
    lastName: 'User',
    room: '100',
    email: 'test@school.edu',
    phone: '8435551234',
    subcommunities: new Set(),
    statedAvailability: [],
    ...overrides
  };
}

export function createMockConnection(
  source: string,
  target: string,
  strength: number = 1.0
): Connection {
  return {
    id: crypto.randomUUID(),
    source,
    target,
    type: ConnectionType.SHARED_INTEREST,
    strength,
    is_bridge_edge: false,
    touches_subcommunities: new Set()
  };
}

// ============================================================================
// 8. TEST COVERAGE REQUIREMENTS
// ============================================================================

/*
MINIMUM TEST COVERAGE FOR v1 RELEASE:

PARSING LAYER:
â–¡ name_parser.ts - 95% coverage
  - All Unicode character sets
  - All suffix patterns
  - Edge cases (single names, empty input)

â–¡ phone_parser.ts - 90% coverage
  - US formats
  - International detection
  - Invalid input

â–¡ availability_parser.ts - 90% coverage
  - All negation patterns
  - Time range parsing
  - Inversion logic

ANALYSIS LAYER:
â–¡ community_analysis.ts - 85% coverage
  - Component counting
  - Î²â‚ calculation
  - Isolation detection

SCHEDULING LAYER:
â–¡ scheduler.ts - 85% coverage
  - Successful scheduling
  - Failure reasons
  - Suggestion generation

CSV IMPORT:
â–¡ csv_import.ts - 90% coverage
  - Column detection
  - Error handling
  - Warning generation

INTEGRATION:
â–¡ Full workflow tests - at least 5 scenarios
  - Happy path (OCR success)
  - OCR fallback to CSV
  - Scheduling with conflicts
  - Community with isolates
  - Multi-pass scheduling improvement
*/
```

---

# MODULE 11: ENHANCED CSV COLUMN DETECTION

**Problem:** What if CSV headers don't match expected patterns?
**Solution:** Smart fallback with user confirmation and manual mapping UI

```typescript
// csv_column_detector.ts - Enhanced column detection with mismatch handling

// ============================================================================
// COLUMN DETECTION RESULT
// ============================================================================

interface ColumnDetectionResult {
  mapping: Record<string, string>;  // CSV header -> our field
  confidence: 'high' | 'medium' | 'low' | 'manual_required';
  matchedColumns: string[];         // Columns we auto-detected
  unmatchedColumns: string[];       // Columns we couldn't identify
  missingRequired: string[];        // Required fields not found
  suggestions: ColumnSuggestion[];  // For UI to show user
}

interface ColumnSuggestion {
  csvColumn: string;
  possibleFields: {
    field: string;
    confidence: number;
    reason: string;
  }[];
}

// ============================================================================
// ENHANCED COLUMN DETECTION
// ============================================================================

function detectColumnMappingEnhanced(headers: string[]): ColumnDetectionResult {
  const mapping: Record<string, string> = {};
  const matchedColumns: string[] = [];
  const unmatchedColumns: string[] = [];
  const suggestions: ColumnSuggestion[] = [];

  // Required fields
  const requiredFields = ['name', 'room'];  // At minimum need name and room

  // Patterns for each field (ordered by specificity)
  const patterns: Record<string, { regex: RegExp[]; priority: number }> = {
    firstName: {
      regex: [/^first\s*name$/i, /^fname$/i, /^given\s*name$/i, /^first$/i],
      priority: 1
    },
    lastName: {
      regex: [/^last\s*name$/i, /^lname$/i, /^surname$/i, /^family\s*name$/i, /^last$/i],
      priority: 1
    },
    name: {
      regex: [/^name$/i, /^full\s*name$/i, /^student\s*name$/i, /^resident\s*name$/i, /^resident$/i],
      priority: 2
    },
    room: {
      regex: [/^room$/i, /^room\s*#$/i, /^room\s*(num|number)$/i, /^unit$/i, /^apt$/i, /^apartment$/i],
      priority: 1
    },
    email: {
      regex: [/^e?-?mail$/i, /^email\s*address$/i],
      priority: 3
    },
    phone: {
      regex: [/^phone$/i, /^cell$/i, /^mobile$/i, /^tel$/i, /^telephone$/i, /^contact$/i],
      priority: 3
    },
  };

  // Phase 1: Exact pattern matching
  for (const header of headers) {
    const normalizedHeader = header.trim();
    let matched = false;

    for (const [field, { regex }] of Object.entries(patterns)) {
      if (regex.some(r => r.test(normalizedHeader))) {
        mapping[normalizedHeader] = field;
        matchedColumns.push(normalizedHeader);
        matched = true;
        break;
      }
    }

    if (!matched) {
      unmatchedColumns.push(normalizedHeader);
    }
  }

  // Phase 2: Fuzzy matching for unmatched columns
  for (const header of unmatchedColumns) {
    const suggestion = generateColumnSuggestion(header, patterns, mapping);
    if (suggestion.possibleFields.length > 0) {
      suggestions.push(suggestion);
    }
  }

  // Phase 3: Check for missing required fields
  const missingRequired: string[] = [];

  // Check if we have name (either combined or firstName+lastName)
  const hasName = Object.values(mapping).includes('name');
  const hasFirstName = Object.values(mapping).includes('firstName');
  const hasLastName = Object.values(mapping).includes('lastName');

  if (!hasName && !(hasFirstName || hasLastName)) {
    missingRequired.push('name (or firstName/lastName)');
  }

  if (!Object.values(mapping).includes('room')) {
    missingRequired.push('room');
  }

  // Determine overall confidence
  let confidence: 'high' | 'medium' | 'low' | 'manual_required';

  if (missingRequired.length > 0) {
    confidence = 'manual_required';
  } else if (unmatchedColumns.length === 0) {
    confidence = 'high';
  } else if (unmatchedColumns.length <= 2) {
    confidence = 'medium';
  } else {
    confidence = 'low';
  }

  return {
    mapping,
    confidence,
    matchedColumns,
    unmatchedColumns,
    missingRequired,
    suggestions
  };
}

function generateColumnSuggestion(
  header: string,
  patterns: Record<string, { regex: RegExp[]; priority: number }>,
  existingMapping: Record<string, string>
): ColumnSuggestion {
  const possibleFields: ColumnSuggestion['possibleFields'] = [];
  const normalizedHeader = header.toLowerCase().replace(/[^a-z0-9]/g, '');

  // Check for partial matches
  const fieldKeywords: Record<string, string[]> = {
    firstName: ['first', 'fname', 'given'],
    lastName: ['last', 'lname', 'surname', 'family'],
    name: ['name', 'student', 'resident', 'person'],
    room: ['room', 'unit', 'apt', 'dorm', 'hall', 'building'],
    email: ['email', 'mail', 'address'],
    phone: ['phone', 'cell', 'mobile', 'tel', 'contact', 'number'],
  };

  for (const [field, keywords] of Object.entries(fieldKeywords)) {
    // Skip if field already mapped
    if (Object.values(existingMapping).includes(field)) continue;

    for (const keyword of keywords) {
      if (normalizedHeader.includes(keyword)) {
        possibleFields.push({
          field,
          confidence: 0.6,
          reason: `Header contains '${keyword}'`
        });
        break;
      }
    }
  }

  // Sort by confidence
  possibleFields.sort((a, b) => b.confidence - a.confidence);

  return { csvColumn: header, possibleFields };
}

// ============================================================================
// COLUMN MAPPING UI COMPONENT
// ============================================================================

interface ColumnMappingUIProps {
  headers: string[];
  detectionResult: ColumnDetectionResult;
  onConfirm: (mapping: Record<string, string>) => void;
  onCancel: () => void;
}

function ColumnMappingUI({
  headers,
  detectionResult,
  onConfirm,
  onCancel
}: ColumnMappingUIProps) {
  const [mapping, setMapping] = useState(detectionResult.mapping);
  const [hasRequiredFields, setHasRequiredFields] = useState(
    detectionResult.missingRequired.length === 0
  );

  // Available fields to map to
  const availableFields = [
    { value: '', label: '-- Skip this column --' },
    { value: 'firstName', label: 'First Name' },
    { value: 'lastName', label: 'Last Name' },
    { value: 'name', label: 'Full Name' },
    { value: 'room', label: 'Room Number' },
    { value: 'email', label: 'Email' },
    { value: 'phone', label: 'Phone' },
  ];

  const handleMappingChange = (csvColumn: string, field: string) => {
    const newMapping = { ...mapping };

    if (field === '') {
      delete newMapping[csvColumn];
    } else {
      newMapping[csvColumn] = field;
    }

    setMapping(newMapping);

    // Check required fields
    const hasName = Object.values(newMapping).includes('name') ||
      (Object.values(newMapping).includes('firstName') ||
       Object.values(newMapping).includes('lastName'));
    const hasRoom = Object.values(newMapping).includes('room');

    setHasRequiredFields(hasName && hasRoom);
  };

  return (
    <div className="column-mapping-ui">
      <header>
        <h2>Map CSV Columns</h2>

        {/* Confidence indicator */}
        <div className={`confidence-indicator ${detectionResult.confidence}`}>
          {detectionResult.confidence === 'high' && (
            <span>âœ“ All columns auto-detected</span>
          )}
          {detectionResult.confidence === 'medium' && (
            <span>âš  Some columns need verification</span>
          )}
          {detectionResult.confidence === 'low' && (
            <span>âš  Multiple columns unrecognized</span>
          )}
          {detectionResult.confidence === 'manual_required' && (
            <span>âŒ Required columns not found - please map manually</span>
          )}
        </div>
      </header>

      {/* Missing required fields warning */}
      {detectionResult.missingRequired.length > 0 && (
        <div className="missing-required-warning">
          <h4>Missing Required Fields:</h4>
          <ul>
            {detectionResult.missingRequired.map(field => (
              <li key={field}>{field}</li>
            ))}
          </ul>
          <p>Please map these columns below to continue.</p>
        </div>
      )}

      {/* Column mapping table */}
      <table className="mapping-table">
        <thead>
          <tr>
            <th>CSV Column</th>
            <th>Sample Data</th>
            <th>Maps To</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          {headers.map(header => {
            const isMatched = detectionResult.matchedColumns.includes(header);
            const suggestion = detectionResult.suggestions.find(
              s => s.csvColumn === header
            );

            return (
              <tr key={header} className={isMatched ? 'matched' : 'unmatched'}>
                <td className="csv-column">{header}</td>
                <td className="sample-data">
                  {/* Would show first row sample here */}
                  <span className="sample-preview">...</span>
                </td>
                <td>
                  <select
                    value={mapping[header] || ''}
                    onChange={(e) => handleMappingChange(header, e.target.value)}
                    className={isMatched ? 'auto-detected' : ''}
                  >
                    {availableFields.map(({ value, label }) => (
                      <option key={value} value={value}>{label}</option>
                    ))}
                  </select>
                </td>
                <td className="status">
                  {isMatched && <span className="badge success">Auto</span>}
                  {!isMatched && suggestion && (
                    <span className="badge warning">
                      Maybe: {suggestion.possibleFields[0]?.field}?
                    </span>
                  )}
                  {!isMatched && !suggestion && (
                    <span className="badge info">Manual</span>
                  )}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>

      {/* Suggestions panel */}
      {detectionResult.suggestions.length > 0 && (
        <div className="suggestions-panel">
          <h4>Suggestions</h4>
          {detectionResult.suggestions.map(suggestion => (
            <div key={suggestion.csvColumn} className="suggestion-item">
              <span className="column-name">"{suggestion.csvColumn}"</span>
              <span className="arrow">â†’</span>
              <div className="suggestions">
                {suggestion.possibleFields.map(pf => (
                  <button
                    key={pf.field}
                    className="suggestion-btn"
                    onClick={() => handleMappingChange(suggestion.csvColumn, pf.field)}
                  >
                    {pf.field} ({Math.round(pf.confidence * 100)}%)
                    <span className="reason">{pf.reason}</span>
                  </button>
                ))}
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Action buttons */}
      <footer className="mapping-actions">
        <button className="btn-secondary" onClick={onCancel}>
          Cancel
        </button>
        <button
          className="btn-primary"
          onClick={() => onConfirm(mapping)}
          disabled={!hasRequiredFields}
        >
          Confirm Mapping
        </button>
        {!hasRequiredFields && (
          <p className="error-hint">
            Map required fields (name and room) to continue
          </p>
        )}
      </footer>
    </div>
  );
}

// ============================================================================
// UPDATED CSV IMPORT FLOW
// ============================================================================

async function importCSVWithMappingUI(
  file: File,
  onMappingRequired: (
    headers: string[],
    result: ColumnDetectionResult
  ) => Promise<Record<string, string>>
): Promise<Result<CSVImportResult, ParseError>> {

  return new Promise((resolve) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      preview: 1,  // First just get headers
      complete: async (previewResults) => {
        const headers = previewResults.meta.fields || [];

        // Detect columns
        const detection = detectColumnMappingEnhanced(headers);

        // If confidence is low or manual required, show UI
        let finalMapping = detection.mapping;

        if (detection.confidence === 'manual_required' ||
            detection.confidence === 'low') {
          // Show mapping UI and wait for user
          finalMapping = await onMappingRequired(headers, detection);
        }

        // Now parse full file with confirmed mapping
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            // ... rest of parsing logic with finalMapping
            const residents: Resident[] = [];
            const warnings: string[] = [];

            for (let i = 0; i < results.data.length; i++) {
              const row = results.data[i] as Record<string, string>;
              const resident = parseCSVRow(row, finalMapping, i + 2);

              if (resident.ok) {
                residents.push(resident.value);
              } else {
                warnings.push(`Row ${i + 2}: ${resident.error.message}`);
              }
            }

            resolve(Ok({
              residents,
              warnings,
              columnMapping: finalMapping
            }));
          }
        });
      }
    });
  });
}

// ============================================================================
// COLUMN MAPPING PRESETS
// ============================================================================

// Common CSV formats from different systems
const KNOWN_FORMATS: Record<string, Record<string, string>> = {
  'Banner': {
    'STUDENT_NAME': 'name',
    'ROOM_NUMBER': 'room',
    'EMAIL_ADDRESS': 'email',
    'PHONE_NUMBER': 'phone',
  },
  'StarRez': {
    'Resident Name': 'name',
    'Room': 'room',
    'Email': 'email',
    'Mobile': 'phone',
  },
  'RMS': {
    'Student': 'name',
    'Assignment': 'room',
    'School Email': 'email',
    'Cell Phone': 'phone',
  },
  'Symplicity': {
    'Full Name': 'name',
    'Room Assignment': 'room',
    'Primary Email': 'email',
    'Phone': 'phone',
  },
};

function detectKnownFormat(headers: string[]): string | null {
  for (const [formatName, expectedMapping] of Object.entries(KNOWN_FORMATS)) {
    const expectedHeaders = Object.keys(expectedMapping);
    const matchCount = expectedHeaders.filter(h => headers.includes(h)).length;

    // If 80%+ match, it's this format
    if (matchCount >= expectedHeaders.length * 0.8) {
      return formatName;
    }
  }
  return null;
}
```
